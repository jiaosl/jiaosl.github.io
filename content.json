[{"title":"正则详解","date":"2017-06-13T15:13:03.000Z","path":"2017/06/13/正则详解/","text":"转自: JS正则表达式一条龙讲解，从原理和语法到JS正则、ES6正则扩展，最后再到正则实践思路 温馨提示：文章很长很长，保持耐心，必要时可以跳着看，当然用来查也是不错的。 正则啊，就像一座灯塔，当你在字符串的海洋不知所措的时候，总能给你一点思路；正则啊，就像一台验钞机，在你不知道用户提交的钞票真假的时候，总能帮你一眼识别；正则啊，就像一个手电筒，在你需要找什么玩意的时候，总能帮你get你要的东西… —— 节选自 Stinson 同学的语文排比句练习《正则》欣赏了一段文学节选后，我们正式来梳理一遍JS中的正则，本文的首要目的是，防止我经常忘记正则的一些用法，故梳理和写下来加强熟练度和用作参考，次要目的是与君共勉，如有纰漏，请不吝赐教，良辰谢过。 本文既然取题为“一条龙”，就要对得起”龙”，故将包括正则原理、语法一览、JS(ES5)中的正则、ES6对正则的扩展、实践正则的思路，我尽量深入尽量浅出地去讲这些东西(搞得好像真能深入浅出一样的)，如果你只想知道怎么应用，那么看第二、三、五部分，基本就能满足你的需求了，如果想掌握JS中的正则的，那么还是委屈你跟着我的思路来吧，嘿嘿嘿！ 一、原理概论在一开始用正则的时候，就觉得神奇，计算机究竟是怎么根据一个正则表达式来匹配字符串的？直到后来我遇到了一本书叫《计算理论》，看到了正则、DFA、NFA的概念和相互间的联系，才有一些恍然小悟的意思。 但如果真的要从原理上吃透正则表达式，那么恐怕最好的方式是： 首先去找一本专门讲正则的书去看看，O’REILLY的“动物总动员”系列里就有；2. 再自己实现一个正则引擎。 而本文的重点在于JS中正则的应用，故原理仅作简单介绍（因为我也没写过正则引擎，也不深入），一来大致“糊弄下”像我一样的好奇宝宝们对正则原理的疑惑，二来知道一些原理方面基本的知识，对于理解语法和写正则是大有裨益的。 1. 正则引擎为什么正则能有效，因为有引擎，这和为什么JS能执行一样，有JS引擎，所谓正则引擎，可以理解为根据你的正则表达式用算法去模拟一台机器，这台机器有很多状态，通过读取待测的字符串，在这些状态间跳来跳去，如果最后停在了“终结状态”(Happy Ending)，那么就Say I Do，否则Say You Are a Good Man。如此将一个正则表达式转换为一个可在有限的步数中计算出结果的机器，那么就实现了引擎。 正则的引擎大致可分为两类：DFA和NFA DFA (Deterministic finite automaton) 确定型有穷自动机2. NFA (Non-deterministic finite automaton) 非确定型有穷自动机，大部分都是NFA 这里的“确定型”指，对于某个确定字符的输入，这台机器的状态会确定地从a跳到b，“非确定型”指，对于某个确定字符的输入，这台机器可能有好几种状态的跳法；这里的“有穷”指，状态是有限的，可以在有限的步数内确定某个字符串是被接受还是发好人卡的；这里的“自动机”，可以理解为，一旦这台机器的规则设定完成，就可以自行判断了，不要人看。 DFA引擎不需要进行回溯，所以匹配效率一般情况下要高，但是它并不支持捕获组，于是也就不支持反向引用和$这种形式的引用，也不支持环视(Lookaround)、非贪婪模式等一些NFA引擎特有的特性。 如果想更详细地了解正则、DFA、NFA，那么可以去看一下《计算理论》，然后你可以根据某个正则表达式自己画出一台自动机。 2. 知识储备这一小节对于你理解正则表达式很有用，尤其是明白什么是字符，什么是位置。 2.1 正则眼中的字符串——n个字符，n+1个位置 在上面的“笑声”字符串中，一共有8个字符，这是你能看到的，还有9个位置，这是聪明的人才能看到的。为什么要有字符还要有位置呢？因为位置是可以被匹配的。 那么进一步我们再来理解“占有字符”和“零宽度”: 如果一个子正则表达式匹配到的是字符，而不是位置，而且会被保存到最终的结果中，那个这个子表达式就是占有字符的，比如/ha/（匹配ha）就是占有字符的；* 如果一个子正则匹配的是位置，而不是字符，或者匹配到的内容不保存在结果中（其实也可以看做一个位置），那么这个子表达式是零宽度的，比如/read(?=ing)/（匹配reading，但是只将read放入结果中，下文会详述语法，此处仅仅举例用），其中的(?=ing)就是零宽度的，它本质代表一个位置。 占有字符是互斥的，零宽度是非互斥的。也就是一个字符，同一时间只能由一个子表达式匹配，而一个位置，却可以同时由多个零宽度的子表达式匹配。举个栗子，比如/aa/是匹配不了a的，这个字符串中的a只能由正则的第一个a字符匹配，而不能同时由第二个a匹配（废话）；但是位置是可以多个匹配的，比如/\\b\\ba/是可以匹配a的，虽然正则表达式里有2个表示单词开头位置的\\b元字符，这两个\\b是可以同时匹配位置0（在这个例子中）的。 注意：我们说字符和位置是面向字符串说的，而说占有字符和零宽度是面向正则说的。 2.2 控制权和传动这两个词可能在搜一些博文或者资料的时候会遇到，这里做一个解释先： 控制权是指哪一个正则子表达式（可能为一个普通字符、元字符或元字符序列组成）在匹配字符串，那么控制权就在哪。 传动是指正则引擎的一种机制，传动装置将定位正则从字符串的哪里开始匹配。 正则表达式当开始匹配的时候，一般是由一个子表达式获取控制权，从字符串中的某一个位置开始尝试匹配，一个子表达式开始尝试匹配的位置，是从前一子表达匹配成功的结束位置开始的。 举一个栗子，read(?=ing)ing\\sbook匹配reading book，我们把这个正则看成5个子表达式read、(?=ing)、ing、\\s、book，当然你也可以吧read看做4个单独字符的子表达式，只是我们这里为了方便这么看待。read从位置0开始匹配到位置4，后面的(?=ing)继续从位置4开始匹配，发现位置4后面确实是ing，于是断言匹配成功，也就是整一个(?=ing)就是匹配了位置4这一个位置而已（这里更能理解什么是零宽了吧），然后后面的ing再从位置4开始匹配到位置7，然后\\s再从位置7匹配到位置8，最后的book从位置8匹配到位置12，整一个匹配完成。 3. 匹配之旅“浅”度游（可跳过）说了那么多，我们把自己当做一个正则引擎，一步一步以最小的单位——“字符”和“位置”——去看一下正则匹配的过程，举几个栗子。 3.1 基本匹配正则表达式：easy 源字符串：So easy 匹配过程：首先由正则表达式字符`e`取得控制权，从字符串的位置0开始匹配，遇到字符串字符‘S’，匹配失败，然后正则引擎向前传动，从位置1开始尝试，遇到字符串字符‘o’，匹配失败，继续传动，后面的空格自然也失败，于是从位置3开始尝试匹配，成功匹配字符串字符‘e’，控制权交给正则表达式子表达式（这里也是一个字符）`a`，尝试从上次匹配成功的**结束**位置4开始匹配，成功匹配字符串字符‘a’，后面一直如此匹配到‘y’，然后匹配完成，匹配结果为`easy`。 3.2 零宽匹配正则：^(?=[aeiou])[a-z]+$源字符串：apple` 首先这个正则表示：匹配这样一个从头到尾完整的字符串，这整一个字符串仅由小写字母组成，并且以a、e、i、o、u这5个字母任一字母开头。 匹配过程：首先正则的^（表示字符串开始的位置）获取控制权，从位置0开始匹配，匹配成功，控制权交给(?=[aeiou])，这个子表达式要求该位置右边必须是元音小写字母中的一个，零宽子表达式相互间不互斥，所以从位置0开始尝试匹配，右侧是字符串的‘a’，符合因此匹配成功，所以(?=[aeiou])匹配此处的位置0匹配成功，控制权交给[a-z]+，从位置0开始匹配，字符串‘apple’中的每个字符都匹配成功，匹配到字符串末尾，控制权交回正则的$，尝试匹配字符串结束位置，成功，至此，整个匹配完成。 3.3 贪婪匹配和非贪婪匹配`正则1：{.*} 正则2：{.*?} 源字符串：{233}` 这里有两个正则，在限定符（语法会讲什么是限定符）后面加?符号表示忽略优先量词，也就是非贪婪匹配，这个栗子我剥得快一点。 首先开头的{匹配，两个正则都是一样的表现。 正则1的’.‘为贪婪匹配，所以一直匹配余下字符串’233}’，匹配到字符串结束位置，只是每次匹配，都记录一个备选状态，为了以后回溯，每次匹配有两条路，选择了匹配这条路，但记一下这里还可以有不匹配这条路，如果前面死胡同了，可以退回来，此时控制权交还给正则的}，去匹配字符串结束位置，失败，于是回溯，意思就是说前面的`.你吃的太多了，吐一个出来，于是控制权回给.，吐出一个}（其实是用了前面记录的备选状态，尝试不用.去匹配&#39;}&#39;），控制权再给正则的}`，这次匹配就成功了。 正则2的.*?为非贪婪匹配，尽可能少地匹配，所以匹配’233}’的每一个字符的时候，都是尝试不匹配，但是一但控制权交还给最后的}就发现出问题了，赶紧回溯乖乖匹配，于是每一个字符都如此，最终匹配成功。 云里雾里？这就对了！可以移步去下面推荐的博客看看： 想详细了解贪婪和非贪婪匹配原理以及获取更多正则相关原理，除了看书之外，推荐去一个CSDN的博客 雁过无痕-博客频道 - CSDN.NET ，讲解得很详细和透彻 二、语法一览正则的语法相信许多人已经看过deerchao写的30分钟入门教程，我也是从那篇文字中入门的，deerchao从语法逻辑的角度以.NET正则的标准来讲述了正则语法，而我想重新组织一遍，以便于应用的角度、以JS为宿主语言来重新梳理一遍语法，这将便于我们把语言描述翻译成正则表达式。 下面这张一览图（可能需要放大），整理了常用的正则语法，并且将JS不支持的语法特性以红色标注出来了（正文将不会描述这些不支持的特性），语法部分的详细描述也将根据下面的图，从上到下，从左到右的顺序来梳理，尽量不啰嗦。 1. 要用某类常见字符——简单元字符为什么这里要加简单2个字，因为在正则中，\\d、\\w这样的叫元字符，而{n,m}、(?!exp)这样的也叫元字符，所以元字符是在正则中有特定意义的标识，而这一小节讲的是简单的一些元字符。 .匹配除了换行符以外的任意字符，也即是[^\\n]，如果要包含任意字符，可使用(.|\\n) \\w匹配任意字母、数字或者下划线，等价于[a-zA-Z0-9_]，在deerchao的文中还指出可匹配汉字，但是\\w在JS中是不能匹配汉字的 \\s匹配任意空白符，包含换页符\\f、换行符\\n、回车符\\r、水平制表符\\t、垂直制表符\\v \\d匹配数字 \\un匹配n，这里的n是一个有4个十六进制数字表示的Unicode字符，比如\\u597d表示中文字符“好”，那么超过\\uffff编号的字符怎么表示呢？ES6的u修饰符会帮你。 2. 要表示出现次数（重复）——限定符 a*表示字符a连续出现次数 &gt;= 0 次 a+表示字符a连续出现次数 &gt;= 1 次 a?表示字符a出现次数 0 或 1 次 a{5}表示字符a连续出现次数 5 次 a{5,}表示字符a连续出现次数 &gt;= 5次 a{5,10}表示字符a连续出现次数为 5到10次 ，包括5和10 3. 匹配位置——定位符和零宽断言匹配某个位置的表达式都是零宽的，这是主要包含两部分，一是定位符，匹配一个特定位置，二是零宽断言，匹配一个要满足某要求的位置。 定位符有以下几个常用的： \\b匹配单词边界位置，准确的描述是它匹配一个位置，这个位置前后不全是\\w能描述的字符，所以像\\u597d\\babc是可以匹配“好abc”的。 ^匹配字符串开始位置，也就是位置0，如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置 $匹配字符串结束位置，如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置 零宽断言（JS支持的）有以下两个： (?=exp)匹配一个位置，这个位置的右边能匹配表达式exp，注意这个表达式仅仅匹配一个位置，只是它对于这个位置的右边有要求，而右边的东西是不会被放进结果的，比如用read(?=ing)去匹配“reading”，结果是“read”，而“ing”是不会放进结果的 (?!exp)匹配一个位置，这个位置的右边不能匹配表达式exp 4. 想表达“或”的意思——字符簇和分歧我们经常会表达“或”的含义，比如这几个字符中的任意一个都行，再比如匹配5个数字或者5个字母都行等等需求。 字符簇可用来表达字符级别的“或”语义，表示的是方括号中的字符任选一： [abc]表示a、b、c这3个字符中的任意一个，如果字母或者数字是连续的，那么可以用-连起来表示，[b-f]代表从b到f这么多字符中任选一个 [(ab)(cd)]并不会用来匹配字符串“ab”或“cd”，而是匹配a、b、c、d、(、)这6个字符中的任一个，也就是想表达“匹配字符串ab或者cd”这样的需求不能这么做，要这么写ab|cd。但这里要匹配圆括号本身，讲道理是要反斜杠转义的，但是在方括号中，圆括号被当成普通字符看待，即便如此，仍然建议显式地转义 分歧用来表达表达式级别的“或”语义，表示的是匹配|左右任一表达就可： ab|cd会匹配字符串“ab”或者“cd” 会短路，回想下编程语言中逻辑或的短路，所以用(ab|abc)去匹配字符串“abc”，结果会是“ab”，因为竖线左边的已经满足了，就用左边的匹配结果代表整个正则的结果 5. 想表达“非”的意思——反义有时候我们想表达“除了某些字符之外”这样的需求，这个时候就要用到反义 \\W、\\D、\\S、\\B 用大写字母的这几个元字符表示就是对应小写字母匹配内容的反义，这几个依次匹配“除了字母、数字、下划线外的字符”、“非数字字符”、“非空白符”、“非单词边界位置” [^aeiou]表示除了a、e、i、o、u外的任一字符，在方括号中且出现在开头位置的^表示排除，如果^在方括号中不出现在开头位置，那么它仅仅代表^字符本身 6. 整体看待和捕获——分组和后向引用其实你在上面的一些地方已经看到了圆括号，是的，圆括号就是用来分组的，括在一对括号里的就是一个分组。 上面讲的大部分是针对字符级别的，比如重复字母 “A” 5次，可以用A{5}来表示，但是如果想要字符串“ABC”重复5次呢？这个时候就需要用到括号。 括号的第一个作用，将括起来的分组当做一个整体看待，所以你可以像对待字符重复一样在一个分组后面加限定符，比如(ABC){5}。 分组匹配到的内容也就是这个分组捕获到的内容，从左往右，以左括号为标志，每个分组会自动拥有一个从1开始的编号，编号0的分组对应整个正则表达式，JS不支持捕获组显示命名。 括号的第二个作用，分组捕获到的内容，可以在之后通过\\分组编号的形式进行后向引用。比如(ab|cd)123\\1可以匹配“ab123ab”或者“cd123cd”，但是不能匹配“ab123cd”或“cd123ab”，这里有一对括号，也是第一对括号，所以编号为捕获组1，然后在正则中通过\\1去引用了捕获组1的捕获的内容，这叫后向引用。 括号的第三个作用，改变优先级，比如abc|de和(abc|d)e表达的完全不是一个意思。 7. 转义任何在正则表达式中有作用的字符都建议转义，哪怕有些情况下不转义也能正确，比如[]中的圆括号、^符号等。 8. 优先级问题优先级从高到低是： 转义 \\ 括号（圆括号和方括号）(), (?:), (?=), [] 字符和位置 竖线 | 9. 贪婪和非贪婪在限定符中，除了{n}确切表示重复几次，其余的都是一个有下限的范围。 在默认的模式（贪婪）下，会尽可能多的匹配内容。比如用ab*去匹配字符串“abbb”，结果是“abbb”。 而通过在限定符后面加问号?可以进行非贪婪匹配，会尽可能少地匹配。用ab*?去匹配“abbb”，结果会是“a”。 不带问号的限定符也称匹配优先量词，带问号的限定符也称忽略匹配优先量词。 10. 修饰符（匹配选项）其实正则的匹配选项有很多可选，不同的宿主语言环境下可能各有不同，此处就JS的修饰符作一个说明： 加g修饰符：表示全局匹配，模式将被应用到所有字符串，而不是在发现第一个匹配项时停止 加i修饰符：表示不区分大小写 加m修饰符：表示多行模式，会改变^和$的行为，上文已述 三、JS(ES5)中的正则JS中的正则由引用类型RegExp表示，下面主要就RegExp类型的创建、两个主要方法和构造函数属性来展开，然后会提及String类型上的模式匹配，最后会简单罗列JS中正则的一些局限。 1. 创建正则表达式一种是用字面量的方式创建，一种是用构造函数创建，我们始终建议用前者。 `//创建一个正则表达式 var exp = /pattern/flags; //比如 var pattern=/\\b[aeiou][a-z]+\\b/gi; //等价下面的构造函数创建 var pattern=new RegExp(\"\\\\b[aeiou][a-z]+\\\\b\",\"gi\");` 其中pattern可以是任意的正则表达式，flags部分是修饰符，在上文中已经阐述过了，有 g、i、m 这3个（ES5中）。 现在说一下为什么不要用构造函数，因为用构造函数创建正则，可能会导致对一些字符的双重转义，在上面的例子中，构造函数中第一个参数必须传入字符串（ES6可以传字面量），所以字符\\会被转义成\\，因此字面量的\\b会变成字符串中的\\\\b，这样很容易出错，贼多的反斜杠。 2. RegExp上用来匹配提取的方法——exec()`var matches=pattern.exec(str); 接受一个参数：源字符串 返回：结果数组，在没有匹配项的情况下返回null` 结果数组包含两个额外属性，index表示匹配项在字符串中的位置，input表示源字符串，结果数组matches第一项即matches[0]表示匹配整个正则表达式匹配的字符串，matches[n]表示于模式中第n个捕获组匹配的字符串。 要注意的是，第一，exec()永远只返回一个匹配项（指匹配整个正则的），第二，如果设置了g修饰符，每次调用exec()会在字符串中继续查找新匹配项，不设置g修饰符，对一个字符串每次调用exec()永远只返回第一个匹配项。所以如果要匹配一个字符串中的所有需要匹配的地方，那么可以设置g修饰符，然后通过循环不断调用exec方法。 `//匹配所有ing结尾的单词 var str=\"Reading and Writing\"; var pattern=/\\b([a-zA-Z]+)ing\\b/g; var matches; while(matches=pattern.exec(str)){ console.log(matches.index +' '+ matches[0] + ' ' + matches[1]); } //循环2次输出 //0 Reading Read //12 Writing Writ` 3. RegExp上用来测试匹配成功与否的方法——test()`var result=pattern.test(str); 接受一个参数：源字符串 返回：找到匹配项，返回true，没找到返回false` 4. RegExp构造函数属性RegExp构造函数包含一些属性，适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。 RegExp.input或RegExp[&quot;$_&quot;]：最近一次要匹配的字符串 RegExp.lastMatch或RegExp[&quot;$&amp;&quot;]：最近一次匹配项 RegExp.lastParen或RegExp[&quot;$+&quot;]：最近一次匹配的捕获组 RegExp.leftContext或RegExp[&quot;$“]`：input字符串中lastMatch之前的文本 RegExp.rightContext或RegExp[&quot;$&#39;&quot;]：input字符串中lastMatch之后的文本 RegExp[&quot;$n&quot;]：表示第n个捕获组的内容，n取1-9 5. String类型上的模式匹配方法上面提到的exec和test都是在RegExp实例上的方法，调用主体是一个正则表达式，而以字符串为主体调用模式匹配也是最为常用的。 5.1 匹配捕获的match方法在字符串上调用match方法，本质上和在正则上调用exec相同，但是match方法返回的结果数组是没有input和index属性的。 `var str=\"Reading and Writing\"; var pattern=/\\b([a-zA-Z]+)ing\\b/g; //在String上调用match var matches=str.match(pattern); //等价于在RegExp上调用exec var matches=pattern.exec(str);` 5.2 返回索引的search方法接受的参数和match方法相同，要么是一个正则表达式，要么是一个RegExp对象。 `//下面两个控制台输出是一样的，都是5 var str=\"I am reading.\"; var pattern=/\\b([a-zA-Z]+)ing\\b/g; var matches=pattern.exec(str); console.log(matches.index); var pos=str.search(pattern); console.log(pos);` 5.3 查找并替换的replace方法`var result=str.replace(RegExp or String, String or Function); 第一个参数（查找）：RegExp对象或者是一个字符串（这个字符串就被看做一个平凡的字符串） 第二个参数（替换内容）：一个字符串或者是一个函数 返回：替换后的结果字符串，不会改变原来的字符串` 第一个参数是字符串 只会替换第一个子字符串 第一个参数是正则 指定g修饰符，则会替换所有匹配正则的地方，否则只替换第一处 第二个参数是字符串 可以使用一些特殊的字符序列，将正则表达式操作的值插进入，这是很常用的。 $n：匹配第n个捕获组的内容，n取0-9 $nn：匹配第nn个捕获组内容，nn取01-99 $`：匹配子字符串之后的字符串 $&#39;：匹配子字符串之前的字符串 $&amp;：匹配整个模式得字符串 $$：表示$符号本身 第二个参数是一个函数 在只有一个匹配项的情况下，会传递3个参数给这个函数：模式的匹配项、匹配项在字符串中的位置、原始字符串 在有多个捕获组的情况下，传递的参数是模式匹配项、第一个捕获组、第二个、第三个…最后两个参数是模式的匹配项在字符串位置、原始字符串 这个函数要返回一个字符串，表示要替换掉的匹配项 5.4 分隔字符串的split基于指定的分隔符将一个字符串分割成多个子字符串，将结果放入一个数组，接受的第一个参数可以是RegExp对象或者是一个字符串（不会被转为正则），第二个参数可选指定数组大小，确保数组不会超过既定大小。 6 JS（ES5）中正则的局限JS（ES5）中不支持以下正则特性（在一览图中也可以看到）： 匹配字符串开始和结尾的\\A和\\Z锚 向后查找（所以不支持零宽度后发断言） 并集和交集类 原子组 Unicode支持（\\uFFFF之后的） 命名的捕获组 单行和无间隔模式 条件匹配 注释 四、ES6对正则的主要加强ES6对正则做了一些加强，这边仅仅简单罗列以下主要的3点，具体可以去看ES6 1. 构造函数可以传正则字面量了ES5中构造函数是不能接受字面量的正则的，所以会有双重转义，但是ES6是支持的，即便如此，还是建议用字面量创建，简洁高效。 2. u修饰符加了u修饰符，会正确处理大于\\uFFFF的Unicode，意味着4个字节的Unicode字符也可以被支持了。 `// \\uD83D\\uDC2A是一个4字节的UTF-16编码，代表一个字符/^\\uD83D/u.test(‘\\uD83D\\uDC2A’)// false，加了u可以正确处理/^\\uD83D/.test(‘\\uD83D\\uDC2A’)// true，不加u，当做两个unicode字符处理 加了u修饰符，会改变一些正则的行为： .原本只能匹配不大于\\uFFFF的字符，加了u修饰符可以匹配任何Unicode字符 Unicode字符新表示法\\u{码点}必须在加了u修饰符后才是有效的 使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符 使一些反义元字符对于大于\\uFFFF的字符也生效 3. y修饰符y修饰符的作用与g修饰符类似，也是全局匹配，开始从位置0开始，后一次匹配都从上一次匹配成功的下一个位置开始。 不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始。 所以/a/y去匹配&quot;ba&quot;会匹配失败，因为y修饰符要求，在剩余位置第一个位置（这里是位置0）开始就要匹配。 ES6对正则的加强，可以看这篇 五、应用正则的实践思路应用正则，一般是要先想到正则（废话），只要看到和“找”相关的需求并且这个源是可以被字符串化的，就可以想到用正则试试。 一般在应用正则有两类情况，一是验证类问题，另一类是搜索、提取、替换类问题。验证，最常见的如表单验证；搜索，以某些设定的命令加关键词去搜索；提取，从某段文字中提取什么，或者从某个JSON对象中提取什么（因为JSON对象可以字符串化啊）；替换，模板引擎中用到。 1. 验证类问题验证类问题是我们最常遇到的，这个时候其实源字符串长什么样我们是不知道，鬼知道萌萌哒的用户会做出什么邪恶的事情来，推荐的方式是这样的: 首先用白话描述清楚你要怎样的字符串，描述好了之后，就开脑洞地想用户可能输入什么奇怪的东西，就是自己举例，拿一张纸可举一大堆的，有接受的和不接受的（这个是你知道的），这个过程中可能你会去修改之前的描述； 把你的描述拆解开来，翻译成正则表达式； 测试你的正则表达式对你之前举的例子的判断是不是和你预期一致，这里就推荐用在线的JS正则测试去做，不要自己去一遍遍写了。 2. 搜索、提取、替换类问题这类问题，一般我们是知道源文本的格式或者大致内容的，所以在解决这类问题时一般已经会有一些测试的源数据，我们要从这些源数据中提取出什么、或者替换什么。 找到这些手上的源数据中你需要的部分； 观察这些部分的特征，这些部分本身的特征以及这些部分周围的特征，比如这部分前一个符号一定是一个逗号，后一个符号一定是一个冒号，总之就是找规律； 考察你找的特征，首先能不能确切地标识出你要的部分，不会少也不会多，然后考虑下以后的源数据也是如此么，以后会不会这些特征就没有了； 组织你对要找的这部分的描述，描述清楚经过你考察的特征； 翻译成正则表达式； 测试。","comments":true,"categories":[],"tags":[{"name":"正则","slug":"正则","permalink":"http://jiaosl.com/tags/正则/"}]},{"title":"CSS3 黑科技 - 内凹圆角 - 径向渐变实现","date":"2017-06-01T15:30:46.000Z","path":"2017/06/01/CSS3-黑科技-内凹圆角-径向渐变实现/","text":"转自:csdn 圆角，大家一定都会做，border-radius, 内凹圆角如何实现？ 可以拿个白色圆盒子盖住方形盒子的大半边实现，但是这样，是不透明的，背景发生改变时，就要改遮盖盒子的颜色，或者背景是渐变，改起来更麻烦，或背景是图片等等，就直接不太好改了，这种方法就有局限性。 说白了就是遮盖的那部分不透明以后，自适应性不强。 这里介绍一个用径向渐变实现的内凹圆角，可以解决上述问题。可以用CSS生成一个背景透明的内凹圆角。 1. 基本线性渐变1234567div &#123; height: 100px; width: 200px; background-image: linear-gradient(90deg, red, blue);&#125;&lt;div&gt;从左到右的红到蓝渐变&lt;/div&gt;1 2. 加百分比调整渐变范围1234567div &#123; height: 100px; width: 200px; background-image: linear-gradient(90deg, red 20%, blue 80%);&#125;&lt;div&gt;&lt;/div&gt; 3. 浓缩渐变范围，直至重合，形成一个红蓝分隔的两个色块1234567div &#123; height: 100px; width: 200px; background-image: linear-gradient(90deg, red 50%, blue 50%);&#125;&lt;div&gt;&lt;/div&gt; 4. 颜色是可以设置透明色的，transparent, 将红色改成透明色，可以看到只有蓝色的色块了。1234567div &#123; height: 100px; width: 200px; background-image: linear-gradient(90deg, transparent 50%, blue 50%);&#125;&lt;div&gt;&lt;/div&gt; 5. 同理联想到径向渐变，同样缩小渐变圈，直至重合，靠近圆心的颜色设成transparent。123456789/* 径向渐变主体 */.raidal &#123; height: 100px; width: 100px; background:radial-gradient(transparent 50%,blue 50%);&#125;&lt;div class=&apos;raidal&apos;&gt;&lt;/div&gt; 6. 径向渐变是可以设置半径圆心位置的，所以设到左顶角，left top 调整半径大小为 200px，就发现背景透明的内凹圆角实现了。应用时可以用伪元素设置，然后用绝对定位，子绝父相，调整位置，组合成想要的效果 12345678/* 径向渐变主体 */.raidal1 &#123; height: 100px; width: 100px; background:radial-gradient(200px at left top,transparent 50%,blue 50%);&#125;&lt;div class=&apos;raidal1&apos;&gt;&lt;/div&gt; 7. 同理四个方向, 调整圆心位置即可1234567891011121314151617181920/* 左上 */.raidal1 &#123; height: 100px; width: 100px; background:radial-gradient(200px at left top,transparent 50%,blue 50%);&#125;/* 右上 */.raidal2 &#123; height: 100px; width: 100px; background:radial-gradient(200px at right top,transparent 50%,blue 50%);&#125;/* 右下 */.raidal3 &#123; height: 100px; width: 100px; background:radial-gradient(200px at right bottom,transparent 50%,blue 50%);&#125; 1234567891011/* 左下 */.raidal4 &#123; height: 100px; width: 100px; background:radial-gradient(200px at left bottom,transparent 50%,blue 50%);&#125;&lt;div class=&apos;raidal1&apos;&gt;&lt;/div&gt;&lt;div class=&apos;raidal2&apos;&gt;&lt;/div&gt;&lt;div class=&apos;raidal3&apos;&gt;&lt;/div&gt;&lt;div class=&apos;raidal4&apos;&gt;&lt;/div&gt; 8. 同样，不想这么圆角，也是可以椭圆的，半径设两个参数, 就是椭圆。径向渐变有很多参数大家可以自己再尝试调整，可以出现各种奇怪的形状，这里就不演示了。相对来说，内凹圆角就够用了 123456/* 左上 */.ellipse &#123; height: 100px; width: 100px; background:radial-gradient(200px 300px at left top,transparent 50%,blue 50%);&#125;","comments":true,"categories":[{"name":"css3","slug":"css3","permalink":"http://jiaosl.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"http://jiaosl.com/tags/css3/"},{"name":"渐变","slug":"渐变","permalink":"http://jiaosl.com/tags/渐变/"}]},{"title":"css3 渐变","date":"2017-05-19T16:15:39.000Z","path":"2017/05/20/css3 渐变/","text":"渐变分线性渐变(linear-gradient)和径向渐变(radial-gradient);这里写的代码省去了-webkit-,-moz-,-o-这些前缀,使用的时候不要忘记. 线性渐变(linear-gradient) 下面几个属性分开介绍 渐变方向默认的渐变方向:从上到下可以采用角度的方式指定方向:如默认方向(从上到下),也即180deg方向 html :1&lt;div&gt;&lt;/div&gt; css:12345div &#123; height: 100px; width: 200px; background-image: linear-gradient(red, blue);&#125; 45度方向(左下到右上) html :1&lt;div&gt;&lt;/div&gt; css:12345div &#123; height: 100px; width: 200px; background-image: linear-gradient(45deg, red, blue);&#125; 按照下图, 以此类推:0deg : 从 下 到 上45deg: 从 左下 到 右上90deg: 从 左 到 右135deg: 从 左上 到 右下180deg: 从 上 到 下270(-90)deg: 从 右 到 左…表示方向还有另外一种方式,例如将”45deg”换成”to right top” ,或者换成”left bottom”,都表示一样的效果,个人习惯使用角度,其他不演示了. 渐变颜色写在前面的是初始颜色,写在后面的是结束颜色;就像我们以上例子中所写的.我们可以使用rgb,rgba,十六进制或者像以上例子中语义化的颜色值来表示渐变颜色;如果需要用到透明度,需要使用rgba 渐变位置 html :1&lt;div&gt;&lt;/div&gt; css:12345div &#123; height: 100px; width: 200px; background-image: linear-gradient(90deg, red 20%, blue 80%);&#125; 这个渐变位置也就是我们颜色值后面的百分比,这一点不常用,很多人容易把它搞混.拿上例来说,20%表示在渐变这条线上,从渐变长度的20%处开始渐变,20%之前的都是纯red色;80%表示,到渐变长度的80%处停止渐变,80%之后的都是纯blue色;也就是说,渐变区间是渐变这条线上,20%-80%这一区间;默认的渐变区间是0%-100%. 重复线性渐变repeat-linear-gradient函数用于创建重复的线性渐变 html :1&lt;div&gt;&lt;/div&gt; css:12345div &#123; height: 100px; width: 200px; background: repeating-linear-gradient(90deg, red 10%, blue 20%);&#125; 径向渐变(radial-gradient)径向渐变是由中心向外渐变的。可以控制它的中心(默认渐变是中心是center),形状（圆形或者椭圆形）,大小,以及上面讲到的渐变范围等。 html :1&lt;div&gt;&lt;/div&gt; css:12345div &#123; height: 100px; width: 200px; background: radial-gradient(red 20%, blue 80%);&#125;","comments":true,"categories":[{"name":"css3","slug":"css3","permalink":"http://jiaosl.com/categories/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"http://jiaosl.com/tags/css3/"},{"name":"渐变","slug":"渐变","permalink":"http://jiaosl.com/tags/渐变/"}]},{"title":"你知道MVC,MVP和MVVM之间的故事吗?","date":"2017-05-15T14:19:49.000Z","path":"2017/05/15/你知道MVC-MVP和MVVM之间的故事吗/","text":"MVCMVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 MVC优点： 业务逻辑全部分离到Controller中，模块化程度高。当业务逻辑变更的时候,只需要Controller换成另外一个Controller就行了（Swappable Controller）。 观察者模式可以做到多视图同时更新。 MVC缺点: Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，Controller业务逻辑的正确性是无法验证的：Controller更新Model的时候，无法对View的更新操作进行断言。 View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的的Domain Model是不一样的 MVPMVP 是从经典的模式MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会从直接Model中读取数据而不是通过 Controller。 MVP的优点: 模型与视图完全分离，我们可以修改视图而不影响模型 可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部 我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁。 如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试） MVP缺点: 由于对视图的渲染放在了Presenter中，所以视图和Presenter的交互会过于频繁，如果Presenter过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么Presenter也需要变更了。比如说，原本用来呈现Html的Presenter现在也需要用于呈现Pdf了，那么视图很有可能也需要变更。 MVVM因为WPF技术出现，从而使MVP设计模式有所改进，MVVM 模式便是使用的是数据绑定基础架构。它们可以轻松构建UI的必要元素。MVVM代表的是Model-View-ViewModel。ViewModel的含义就是 “Model of View”，视图的模型。它的含义包含了领域模型（Domain Model）和视图的状态（State）。 MVVM优点: MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点1. 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。2. 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。3. 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。4. 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。","comments":true,"categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://jiaosl.com/categories/javaScript/"}],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"http://jiaosl.com/tags/MVVM/"},{"name":"MVC","slug":"MVC","permalink":"http://jiaosl.com/tags/MVC/"},{"name":"　MVP","slug":"MVP","permalink":"http://jiaosl.com/tags/MVP/"}]},{"title":"mongoDB 基础教程笔记","date":"2017-05-11T15:26:02.000Z","path":"2017/05/11/mongoDB-基础教程笔记(二)/","text":"查询处 ,注意 !=","comments":true,"categories":[{"name":"mongoDB","slug":"mongoDB","permalink":"http://jiaosl.com/categories/mongoDB/"}],"tags":[{"name":"mongoDB","slug":"mongoDB","permalink":"http://jiaosl.com/tags/mongoDB/"}]},{"title":"每日阅读2017.5.7-12","date":"2017-05-10T01:33:57.000Z","path":"2017/05/10/每日阅读2017-5-7-12/","text":"https://github.com/Xing-Chuan/blog/blob/master/works/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-2017-05.md 中文技术文档写作规范 前端常用单元测试（工具+框架）步骤归纳 在网上四处收集来的既漂亮又优雅的加载框布局－微信小程序彻底理解从输入URL与页面展现 赞当我们在谈论前端加密时，我们在谈些什么 收藏【浏览器前端优化】本文将围绕浏览器渲染网页的几个核心步骤，解析浏览器前端优化方案 vue全栈开发部署你需要知道的一些事 使用 “5W1H” 写出高可读的 Git Commit Messagegit commit message 是什么? 用git的人都知道,但是估计很多人不会在意它,利用好它,对公司,对项目,对你都会有很好的辅助作用: 利于自己查看项目历史,方便自己定位问题所在 有助于后来人熟悉项目,不至于被后来人骂的很惨 对自己来说,是一种良好的习惯,书写message的时候也是总结和思考的过程,方便记忆和梳理. 比较懒同时还能方便书写git commit message的方法就是使用”5W1H”的法则创建模板,每次规范自己书写message什么是”5W1H”? 是谁做了(who) 在什么时候(when) 什么地点（where） 因为什么（why） 而做了什么事情（what） 他是怎么做的（how）git已将帮我们记录了who,when;我们不需要where;所以就剩下了why,what,how.做个git commit message模板,从今天就开始用上吧!","comments":true,"categories":[{"name":"diurnal reading","slug":"diurnal-reading","permalink":"http://jiaosl.com/categories/diurnal-reading/"}],"tags":[{"name":"每日阅读","slug":"每日阅读","permalink":"http://jiaosl.com/tags/每日阅读/"},{"name":"阅读","slug":"阅读","permalink":"http://jiaosl.com/tags/阅读/"},{"name":"阅读记录","slug":"阅读记录","permalink":"http://jiaosl.com/tags/阅读记录/"}]},{"title":"mongoDB 基础教程笔记","date":"2017-05-09T15:06:42.000Z","path":"2017/05/09/mongoDB-基础教程笔记(一)/","text":"安装从mongoDB官网 下载 MongoDB 的最新版本,直接一路next，如果想自定义安装Choose Setup Type处选择Custon 创建数据目录数据目录需要我们手动创建，这里我在F盘根目录创建了data，在data下面创建了db（命令行，手动都可以） 启动MOngoDB在命令行中执行mongod.exe文件，（必须在你所安装的MongoDB目录下的bin目录内执行）1mongod.exe --dbpath F:\\data\\db 连接MongoDB 在上一步启动过的前提下，双击MongoDB目录下bin目录中的mongo.exe就可以用mongoDB的shell连接数据库，其他种连接方式以后再实验 创建数据库输入命令：12&gt; use jslswiched to db jsl # 输出信息 这时，就会创建出jsl命名的数据库 查看当前所在的数据库:12&gt; dbjsl # 输出信息 查看数据库列表:123&gt; show dbsadmin 0.000GB # 输出信息local 0.000GB # 输出信息 这时，并看不到我们刚创建的jsl的数据库，这是因为个人创建的，空数据库是不会显示的 我们往这个数据库里放一些数据 12&gt; db.jsl.insert(&#123;&quot;name&quot;:&quot;jsl&quot;&#125;)WriteResult(&#123; &quot;nInserted&quot;:1 &#125;) # 输出信息 再次查看数据库列表：1234&gt; show dbsadmin 0.000GB # 输出信息jsl 0.000GB # 输出信息local 0.000GB # 输出信息 删除数据库语法格式1db.dropDatabase() 先查看数据库：1234&gt; show dbsadmin 0.000GB # 输出信息jsl 0.000GB # 输出信息 local 0.000GB # 输出信息 然后切换到jsl数据库中:12&gt; use jslswitched to db jsl # 输出信息 执行删除命令:12&gt; db.dropDatabase()&#123; &quot;dropped&quot; : &quot;jsl&quot;, &quot;ok&quot;: 1 &#125; 然后验证一下，是否删除成功：123&gt; show dbsadmin 0.000GB # 输出信息local 0.000GB # 输出信息 数据库列表只剩下两个，说明jsl数据库已经删除 删除集合语法：1db.collection.drop() 重新再创建一个叫jsl的数据库，并且切换到jsl中，插入数据:1db.jsl.insert(&#123;&quot;name&quot;: &quot;jsl&quot;&#125;) 查看集合：12&gt; show tablesjsl 删除集合：12&gt; db.jsl.drop()true 再查看集合：1show tables 输出为空，说明删除成功 插入文档所有存在集合中的数据都是BSON格式（BSON是 类json的一种二进制形式的存储格式，简称Binary JSON） 插入文档MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：1db.COLLECTION_NAME.insert(document) 实例:在jsl数据库中的col表中插入文档：1234&gt; db.col.insert( title: &apos;MongoDB &apos;, description: &apos;MongoDB 是一个 Nosql 数据库&apos;&#125;) col是集合名，如果集合名不存在，就会自动创建一个，并插入文档，执行下列命令查看是否插入文档：12&gt; bd.col.find()&#123; &quot;_id&quot; : ObjectId(&quot;56064886ade2f21f36b03134&quot;), &quot;title&quot; : &quot;MongoDB 教程&quot;, &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot; &#125; # 输出信息 还有另一种方式是一样的效果：将数据定义为一个变量，将变量插入到数据库123&gt; document= &#123;title: &apos;MongoDB 教程&apos;, description: &apos;MongoDB 是一个 Nosql 数据库&apos;&#125;; 然后执行插入操作：12&gt; db.col.insert(document)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;) # 输出信息 注：db.sol.save(document)命令也可以达到同样的效果，save()传 ‘_id’字段参数的话可以完成更新该 ‘_id’的数据。 更新文档MongoDB 使用 update() 和 save() 方法来更新集合中的文档。接下来让我们详细来看下两个函数的应用及其区别。 update()方法update()方法用于更新已存在的文档 ，语法格式如下：123456789db.collection.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明: query: update的查询条件 update: update的对象和一些更新的操作符(如$,$inc) upsert: 可选,意思是如果不存在update的记录,是否插入objNew; 默认是false. multi: 可选,默认是false:只更新找到的第一条记录;如果参数为true,就是把所有查找到的记录全部更新 writeConcern: 可选,抛出异常的级别. 实例在集合col中插入数据:1234&gt;db.col.insert(&#123; name: &apos;张三&apos;, age: 20&#125;) 然后用update()来更新name:12&gt; db.col.update(&apos;name&apos;: &apos;我是名字&apos;,&#123;$set:&#123;&apos;name&apos;:&apos;我是已更新的名字&apos;&#125;&#125;)WriteResult(&#123; &quot;nMatched&quot;:1,&quot;nUpserted&quot;:0,&quot;nModified&quot;:1 &#125;) # 输出信息 再次输入命令查看数据:123&gt; db.col.find()&#123; &quot;_id&quot; : ObjectId(&quot;5911725e0275fd608c69ed6a&quot;), &quot;name&quot; : &quot;我是已更新的名字&quot; &#125; #输出信息 可以看得出,我们的名字已经被更新.后面如果加参数,的格式如下1db.col.update(&apos;name&apos;: &apos;我是名字&apos;,&#123;$set:&#123;&apos;name&apos;:&apos;我是已更新的名字&apos;&#125;&#125;, &#123;multi:true&#125;) save()方法语法如下:123456db.collection.save( &lt;document&gt;, &#123; writeConcern: &lt;document&gt; &#125;) 参数说明: document: 文档数据. writeConcern: 可选,抛出异常的级别. 实例1db.col.save(&#123; &quot;_id&quot; : ObjectId(&quot;591192d80275fd608c69ed6b&quot;), &quot;name&quot; : &quot;我是来替换之前名字的名字&quot;, &quot;age&quot; : 20 &#125;)","comments":true,"categories":[{"name":"mongoDB","slug":"mongoDB","permalink":"http://jiaosl.com/categories/mongoDB/"}],"tags":[{"name":"mongoDB","slug":"mongoDB","permalink":"http://jiaosl.com/tags/mongoDB/"}]},{"title":"Git常用命令总结","date":"2017-05-03T16:15:39.000Z","path":"2017/05/04/Git常用命令总结/","text":"基础命令 用户设置12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 初始化仓库1git init 把文件添加到仓库1git add filename 把文件提交到仓库1git commit -m &quot;comment message&quot; 初始化一个Git仓库1git init 添加文件到Git仓库 分两步： 第一步，使用命令git add，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 运行git status命令看看结果 1git status 但如果要看看具体修改了什么内容 1git diff filename 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容 版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看123git loggit log --pretty=oneline 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交,上一个版本就是HEAD^ ，上上一个版本就是HEAD^^， 当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100. 123git reset --hard HEAD^git reset --hard 3628164 Git提供了一个命令git reflog用来查看历史 1git reflog HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区（Working Directory）：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区。 版本库（Repository）：工作区有一个隐藏目录“.git”，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用“git add”把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用“git commit”提交更改，实际上就是把暂存区的所有内容提交到当前分支。 git checkout – file 可以丢弃工作区的修改 1git checkout -- filename git checkout – file命令中的“–”很重要，没有“–”，就变成了“创建一个新分支”的命令. 用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区 1git reset HEAD filename git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 确实要从版本库中删除该文件，那就用命令git rm删掉，并且commit 1git rm test.txt 1git commit -m remove test.txt 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本 1git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 远程仓库要关联一个远程库，使用命令1git remote add origin git@server-name:path/repo-name.git 关联后，使用命令第一次推送master分支的所有内容1git push -u origin master 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 用命令git clone克隆一个本地库 Git本身的源代码你既可以用 git://协议来访问1git clone git://git.kernel.org/pub/scm/git/git.git 也可以通过http 协议来访问:1git clone http://www.kernel.org/pub/scm/git/git.git git 分支查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 创建+切换分支：git checkout -b name 合并某分支到当前分支：git merge name 删除分支：git branch -d name 在 当前分支下，要把dev分支的内容合并 1git merge dev 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 用git log –graph命令可以看到分支合并图。 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：1git stash 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： 转换到master分支1git checkout master 创建并转换到的名字为 issue-101 的分支1git checkout -b issue -101 查看存储的工作 用git stash list 1git stash list 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场. 如果要丢弃一个没有被合并过的分支，可以通过git branch -D name强行删除。; 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote或者用git remote -v显示更详细的信息： 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上.1git push origin master 如果要推送其他分支，比如dev，就改成1git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： 1git clone git://git.kernel.org/pub/scm/git/git.git 指定本地dev分支与远程origin/dev分支的链接 123git branch --set -upstream dev origin/devgit pull 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 tag 标签命令git tag name就可以打一个新标签，可以用命令git tag查看所有标签 新建标签1git tag v1.0 给commit id 为25656e2的历史版本打标签1git tag v1.0 25656e2 查看标签 1git show tagname 用git show tagname查看标签信息1git show v1.0 命令git tag name用于新建一个标签，默认为HEAD，也可以指定一个commit id； -a tagname -m “blablabla…”可以指定标签信息； -s tagname -m “blablabla…”可以用PGP签名标签； 命令git tag可以查看所有标签； 推送某个标签到远程，使用命令git push origin tagname，或者，一次性推送全部尚未推送到远程的本地标签123git push origin v1.0git push origin --tags 删除标签 分两步， 删除本地； 删除远程。 删除本地1git tag -d v0.9 删除远程1git push origin :refs/tags/v0.9 命令git push origin tagname可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d tagname可以删除一个本地标签； 命令git push origin :refs/tags/tagname可以删除一个远程标签。 ignore 文件 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 配置别名 如果敲git st就表示git status 1234git config --global alias.st statusgit config global alias.co checkoutgit config global alias.ci commitgit config global alias.br branch git config –global alias.unstage ‘reset HEAD’","comments":true,"categories":[{"name":"git","slug":"git","permalink":"http://jiaosl.com/categories/git/"}],"tags":[{"name":"github","slug":"github","permalink":"http://jiaosl.com/tags/github/"},{"name":"git","slug":"git","permalink":"http://jiaosl.com/tags/git/"}]},{"title":"你真的会使用XMLHttpRequest吗？","date":"2017-04-30T08:38:01.000Z","path":"2017/04/30/你真的会使用XMLHttpRequest吗？/","text":"看到标题时，有些同学可能会想：“我已经用xhr成功地发过很多个Ajax请求了，对它的基本操作已经算挺熟练了。” 我之前的想法和你们一样，直到最近我使用xhr时踩了不少坑儿，我才突然发现其实自己并不够了解xhr，我知道的只是最最基本的使用。于是我决定好好地研究一番xhr的真面目，可拜读了不少博客后都不甚满意，于是我决定认真阅读一遍W3C的XMLHttpRequest标准。看完标准后我如同醍醐灌顶一般，感觉到了从未有过的清澈。这篇文章就是参考W3C的XMLHttpRequest标准和结合一些实践验证总结而来的。 Ajax和XMLHttpRequest我们通常将Ajax等同于XMLHttpRequest，但细究起来它们两个是属于不同维度的2个概念。 以下是我认为对Ajax较为准确的解释：（摘自what is Ajax）AJAX stands for Asynchronous JavaScript and XML. AJAX is a new technique for creating better, faster, and more interactive web applications with the help of XML, HTML, CSS, and Java Script. AJAX is based on the following open standards: Browser-based presentation using HTML and Cascading Style Sheets (CSS). Data is stored in XML format and fetched from the server. Behind-the-scenes data fetches using XMLHttpRequest objects in the browser. JavaScript to make everything happen. 从上面的解释中可以知道：ajax是一种技术方案，但并不是一种新技术。它依赖的是现有的CSS/HTML/Javascript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。 所以我用一句话来总结两者的关系：我们使用XMLHttpRequest对象来发送一个Ajax请求。 XMLHttpRequest的发展历程XMLHttpRequest一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了XMLHttpRequest标准。XMLHttpRequest标准又分为Level 1和Level 2。XMLHttpRequest Level 1主要存在以下缺点： 受同源策略的限制，不能发送跨域请求； 不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据； 在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成； 那么Level 2对Level 1 进行了改进，XMLHttpRequest Level 2中新增了以下功能： 可以发送跨域请求，在服务端允许的情况下； 支持发送和接收二进制数据； 新增formData对象，支持发送表单数据； 发送和获取数据时，可以获取进度信息； 可以设置请求的超时时间； 当然更详细的对比介绍，可以参考阮老师的这篇文章，文章中对新增的功能都有具体代码示例。 XMLHttpRequest兼容性关于xhr的浏览器兼容性，大家可以直接查看“Can I use”这个网站提供的结果XMLHttpRequest兼容性，下面提供一个截图。 从图中可以看到： IE8/IE9、Opera Mini 完全不支持xhr对象 IE10/IE11部分支持，不支持 xhr.responseType为json 部分浏览器不支持设置请求超时，即无法使用xhr.timeout 部分浏览器不支持xhr.responseType为blob 细说XMLHttpRequest如何使用先来看一段使用XMLHttpRequest发送Ajax请求的简单示例代码。 1234567891011121314151617181920212223242526function sendAjax() &#123; //构造表单数据 var formData = new FormData(); formData.append(&apos;username&apos;, &apos;johndoe&apos;); formData.append(&apos;id&apos;, 123456); //创建xhr对象 var xhr = new XMLHttpRequest(); //设置xhr请求的超时时间 xhr.timeout = 3000; //设置响应返回的数据格式 xhr.responseType = &quot;text&quot;; //创建一个 post 请求，采用异步 xhr.open(&apos;POST&apos;, &apos;/server&apos;, true); //注册相关事件回调处理函数 xhr.onload = function(e) &#123; if(this.status == 200||this.status == 304)&#123; alert(this.responseText); &#125; &#125;; xhr.ontimeout = function(e) &#123; ... &#125;; xhr.onerror = function(e) &#123; ... &#125;; xhr.upload.onprogress = function(e) &#123; ... &#125;; //发送数据 xhr.send(formData);&#125; 上面是一个使用xhr发送表单数据的示例，整个流程可以参考注释。 接下来我将站在使用者的角度，以问题的形式介绍xhr的基本使用。我对每一个问题涉及到的知识点都会进行比较细致地介绍，有些知识点可能是你平时忽略关注的。 如何设置request header在发送Ajax请求（实质是一个HTTP请求）时，我们可能需要设置一些请求头部信息，比如content-type、connection、cookie、accept-xxx等。xhr提供了setRequestHeader来允许我们修改请求 header。 void setRequestHeader(DOMString header, DOMString value); 注意点： 方法的第一个参数 header 大小写不敏感，即可以写成content-type，也可以写成Content-Type，甚至写成content-Type; Content-Type的默认值与具体发送的数据类型有关，请参考本文【可以发送什么类型的数据】一节； setRequestHeader必须在open()方法之后，send()方法之前调用，否则会抛错； setRequestHeader可以调用多次，最终的值不会采用覆盖override的方式，而是采用追加append的方式。下面是一个示例代码： 123456var client = new XMLHttpRequest();client.open(&apos;GET&apos;, &apos;demo.cgi&apos;);client.setRequestHeader(&apos;X-Test&apos;, &apos;one&apos;);client.setRequestHeader(&apos;X-Test&apos;, &apos;two&apos;);// 最终request header中&quot;X-Test&quot;为: one, twoclient.send(); 如何获取response headerxhr提供了2个用来获取响应头部的方法：getAllResponseHeaders和getResponseHeader。前者是获取 response 中的所有header 字段，后者只是获取某个指定 header 字段的值。另外，getResponseHeader(header)的header参数不区分大小写。 DOMString getAllResponseHeaders();DOMString getResponseHeader(DOMString header); 这2个方法看起来简单，但却处处是坑儿。 你是否遇到过下面的坑儿?——反正我是遇到了。。。 使用getAllResponseHeaders()看到的所有response header与实际在控制台 Network 中看到的 response header 不一样 使用getResponseHeader()获取某个 header 的值时，浏览器抛错Refused to get unsafe header &quot;XXX&quot; 经过一番寻找最终在 Stack Overflow找到了答案。 原因1：W3C的 xhr 标准中做了限制，规定客户端无法获取 response 中的 Set-Cookie、Set-Cookie2这2个字段，无论是同域还是跨域请求； 原因2：W3C 的 cors 标准对于跨域请求也做了限制，规定对于跨域请求，客户端允许获取的response header字段只限于“simple response header”和“Access-Control-Expose-Headers” （两个名词的解释见下方）。 “simple response header“包括的 header 字段有：Cache-Control,Content-Language,Content-Type,Expires,Last-Modified,Pragma;“Access-Control-Expose-Headers“：首先得注意是”Access-Control-Expose-Headers“进行跨域请求时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段。 所以getAllResponseHeaders()只能拿到限制以外（即被视为safe）的header字段，而不是全部字段；而调用getResponseHeader(header)方法时，header参数必须是限制以外的header字段，否则调用就会报Refused to get unsafe header的错误。 如何指定xhr.response的数据类型有些时候我们希望xhr.response返回的就是我们想要的数据类型。比如：响应返回的数据是纯JSON字符串，但我们期望最终通过xhr.response拿到的直接就是一个 js 对象，我们该怎么实现呢？有2种方法可以实现，一个是level 1就提供的overrideMimeType()方法，另一个是level 2才提供的xhr.responseType属性。 xhr.overrideMimeType()overrideMimeType是xhr level 1就有的方法，所以浏览器兼容性良好。这个方法的作用就是用来重写response的content-type，这样做有什么意义呢？比如：server 端给客户端返回了一份document或者是 xml文档，我们希望最终通过xhr.response拿到的就是一个DOM对象，那么就可以用xhr.overrideMimeType(&#39;text/xml; charset = utf-8&#39;)来实现。 再举一个使用场景，我们都知道xhr level 1不支持直接传输blob二进制数据，那如果真要传输 blob 该怎么办呢？当时就是利用overrideMimeType方法来解决这个问题的。 下面是一个获取图片文件的代码示例： 12345678910111213141516171819202122var xhr = new XMLHttpRequest();//向 server 端获取一张图片xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);// 这行是关键！//将响应数据按照纯文本格式来解析，字符集替换为用户自己定义的字符集xhr.overrideMimeType(&apos;text/plain; charset=x-user-defined&apos;);xhr.onreadystatechange = function(e) &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; //通过 responseText 来获取图片文件对应的二进制字符串 var binStr = this.responseText; //然后自己再想方法将逐个字节还原为二进制数据 for (var i = 0, len = binStr.length; i &lt; len; ++i) &#123; var c = binStr.charCodeAt(i); //String.fromCharCode(c &amp; 0xff); var byte = c &amp; 0xff; &#125; &#125;&#125;;xhr.send(); 代码示例中xhr请求的是一张图片，通过将 response 的 content-type 改为’text/plain; charset=x-user-defined’，使得 xhr 以纯文本格式来解析接收到的blob 数据，最终用户通过this.responseText拿到的就是图片文件对应的二进制字符串，最后再将其转换为 blob 数据。 xhr.responseTyperesponseType是xhr level 2新增的属性，用来指定xhr.response的数据类型，目前还存在些兼容性问题，可以参考本文的【XMLHttpRequest的兼容性】这一小节。那么responseType可以设置为哪些格式呢，我简单做了一个表，如下： 值 xhr.response 数据类型 说明 &quot;&quot; String字符串 默认值(在不设置responseType时) &quot;text&quot; String字符串 &quot;document&quot; Document对象 希望返回 XML 格式数据时使用 &quot;json&quot; javascript 对象 存在兼容性问题，IE10/IE11不支持 &quot;blob&quot; Blob对象 &quot;arrayBuffer&quot; ArrayBuffer对象 下面是同样是获取一张图片的代码示例，相比xhr.overrideMimeType,用xhr.response来实现简单得多。 1234567891011121314var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);//可以将`xhr.responseType`设置为`&quot;blob&quot;`也可以设置为`&quot; arrayBuffer&quot;`//xhr.responseType = &apos;arrayBuffer&apos;;xhr.responseType = &apos;blob&apos;;xhr.onload = function(e) &#123; if (this.status == 200) &#123; var blob = this.response; ... &#125;&#125;;xhr.send(); 小结虽然在xhr level 2中，2者是共同存在的。但其实不难发现，xhr.responseType就是用来取代xhr.overrideMimeType()的，xhr.responseType功能强大的多，xhr.overrideMimeType()能做到的xhr.responseType都能做到。所以我们现在完全可以摒弃使用xhr.overrideMimeType()了。 如何获取response数据xhr提供了3个属性来获取请求返回的数据，分别是：xhr.response、xhr.responseText、xhr.responseXML xhr.response 默认值：空字符串&quot;&quot; 当请求完成时，此属性才有正确的值 请求未完成时，此属性的值可能是&quot;&quot;或者 null，具体与 xhr.responseType有关：当responseType为&quot;&quot;或&quot;text&quot;时，值为&quot;&quot;；responseType为其他值时，值为 null xhr.responseText 默认值为空字符串&quot;&quot; 只有当 responseType 为&quot;text&quot;、&quot;&quot;时，xhr对象上才有此属性，此时才能调用xhr.responseText，否则抛错 只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串&quot;&quot;：请求未完成、请求失败 xhr.responseXML 默认值为 null 只有当 responseType 为&quot;text&quot;、&quot;&quot;、&quot;document&quot;时，xhr对象上才有此属性，此时才能调用xhr.responseXML，否则抛错 只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为null：请求未完成、请求失败、请求成功但返回数据无法被正确解析时 如何追踪ajax请求的当前状态在发一个ajax请求后，如果想追踪请求当前处于哪种状态，该怎么做呢？ 用xhr.readyState这个属性即可追踪到。这个属性是只读属性，总共有5种可能值，分别对应xhr不同的不同阶段。每次xhr.readyState的值发生变化时，都会触发xhr.onreadystatechange事件，我们可以在这个事件中进行相关状态判断。 123456789101112131415xhr.onreadystatechange = function () &#123; switch(xhr.readyState)&#123; case 1://OPENED //do something break; case 2://HEADERS_RECEIVED //do something break; case 3://LOADING //do something break; case 4://DONE //do something break; &#125; 值 状态 描述 0 UNSENT (初始状态，未打开) 此时xhr对象被成功构造，open()方法还未被调用 1 OPENED (已打开，未发送) open()方法已被成功调用，send()方法还未被调用。注意：只有xhr处于OPENED状态，才能调用xhr.setRequestHeader()和xhr.send(),否则会报错 2 HEADERS_RECEIVED(已获取响应头) send()方法已经被调用, 响应头和响应状态已经返回 3 LOADING (正在下载响应体) 响应体(response entity body)正在下载中，此状态下通过xhr.response可能已经有了响应数据 4 DONE (整个数据传输过程结束) 整个数据传输过程结束，不管本次请求是成功还是失败 如何设置请求的超时时间如果请求过了很久还没有成功，为了不会白白占用的网络资源，我们一般会主动终止请求。XMLHttpRequest提供了timeout属性来允许设置请求的超时时间。 xhr.timeout 单位：milliseconds 毫秒默认值：0，即不设置超时 很多同学都知道：从请求开始 算起，若超过 timeout 时间请求还没有结束（包括成功/失败），则会触发ontimeout事件，主动结束该请求。 【那么到底什么时候才算是请求开始 ？】——xhr.onloadstart事件触发的时候，也就是你调用xhr.send()方法的时候。因为xhr.open()只是创建了一个连接，但并没有真正开始数据的传输，而xhr.send()才是真正开始了数据的传输过程。只有调用了xhr.send()，才会触发xhr.onloadstart 。 【那么什么时候才算是请求结束 ？】—— xhr.loadend事件触发的时候。 另外，还有2个需要注意的坑儿： 可以在 send()之后再设置此xhr.timeout，但计时起始点仍为调用xhr.send()方法的时刻。 当xhr为一个sync同步请求时，xhr.timeout必须置为0，否则会抛错。原因可以参考本文的【如何发一个同步请求】一节。 如何发一个同步请求xhr默认发的是异步请求，但也支持发同步请求（当然实际开发中应该尽量避免使用）。到底是异步还是同步请求，由xhr.open（）传入的async参数决定。 open(method, url [, async = true [, username = null [, password = null]]]) method: 请求的方式，如GET/POST/HEADER等，这个参数不区分大小写 url: 请求的地址，可以是相对地址如example.[PHP](http://lib.csdn.net/base/php &quot;PHP知识库&quot;)，这个相对是相对于当前网页的url路径；也可以是绝对地址如http://www.example.com/example.php async: 默认值为true，即为异步请求，若async=false，则为同步请求 在我认真研读W3C 的 xhr 标准前，我总以为同步请求和异步请求只是阻塞和非阻塞的区别，其他什么事件触发、参数设置应该是一样的，事实证明我错了。 W3C 的 xhr标准中关于open()方法有这样一段说明： Throws an “InvalidAccessError” exception if async is false, the JavaScript global environment is a document environment, and either the timeout attribute is not zero, the withCredentials attribute is true, or the responseType attribute is not the empty string. 从上面一段说明可以知道，当xhr为同步请求时，有如下限制： xhr.timeout必须为0 xhr.withCredentials必须为 false xhr.responseType必须为&quot;&quot;（注意置为&quot;text&quot;也不允许） 若上面任何一个限制不满足，都会抛错，而对于异步请求，则没有这些参数设置上的限制。 之前说过页面中应该尽量避免使用sync同步请求，为什么呢？因为我们无法设置请求超时时间（xhr.timeout为0，即不限时）。在不限制超时的情况下，有可能同步请求一直处于pending状态，服务端迟迟不返回响应，这样整个页面就会一直阻塞，无法响应用户的其他交互。 另外，标准中并没有提及同步请求时事件触发的限制，但实际开发中我确实遇到过部分应该触发的事件并没有触发的现象。如在 chrome中，当xhr为同步请求时，在xhr.readyState由2变成3时，并不会触发 onreadystatechange事件，xhr.upload.onprogress和 xhr.onprogress事件也不会触发。 如何获取上传、下载的进度在上传或者下载比较大的文件时，实时显示当前的上传、下载进度是很普遍的产品需求。我们可以通过onprogress事件来实时显示进度，默认情况下这个事件每50ms触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的onprogress事件： 上传触发的是xhr.upload对象的 onprogress事件 下载触发的是xhr对象的onprogress事件 1234567xhr.onprogress = updateProgress;xhr.upload.onprogress = updateProgress;function updateProgress(event) &#123; if (event.lengthComputable) &#123; var completedPercent = event.loaded / event.total; &#125; &#125; 可以发送什么类型的数据 void send(data); xhr.send(data)的参数data可以是以下几种类型： ArrayBuffer Blob Document DOMString FormData null 如果是 GET/HEAD请求，send()方法一般不传参或传 null。不过即使你真传入了参数，参数也最终被忽略，xhr.send(data)中的data会被置为 null. xhr.send(data)中data参数的数据类型会影响请求头部content-type的默认值： 如果data是 Document 类型，同时也是HTML Document类型，则content-type默认值为text/html;charset=UTF-8;否则为application/xml;charset=UTF-8； 如果data是 DOMString 类型，content-type默认值为text/plain;charset=UTF-8； 如果data是 FormData 类型，content-type默认值为multipart/form-data; boundary=[xxx] 如果data是其他类型，则不会设置content-type的默认值 当然这些只是content-type的默认值，但如果用xhr.setRequestHeader()手动设置了中content-type的值，以上默认值就会被覆盖。 另外需要注意的是，若在断网状态下调用xhr.send(data)方法，则会抛错：Uncaught NetworkError: Failed to execute &#39;send&#39; on &#39;XMLHttpRequest&#39;。一旦程序抛出错误，如果不 catch 就无法继续执行后面的代码，所以调用 xhr.send(data)方法时，应该用 try-catch捕捉错误。 12345try&#123; xhr.send(data) &#125;catch(e) &#123; //doSomething... &#125;; xhr.withCredentials与 CORS 什么关系 我们都知道，在发同域请求时，浏览器会将cookie自动加在request header中。但大家是否遇到过这样的场景：在发送跨域请求时，cookie并没有自动加在request header中。 造成这个问题的原因是：在CORS标准中做了规定，默认情况下，浏览器在发送跨域请求时，不能发送任何认证信息（credentials）如”cookies“和”HTTP authentication schemes“。除非xhr.withCredentials为true（xhr对象有一个属性叫withCredentials，默认值为false）。 所以根本原因是cookies也是一种认证信息，在跨域请求中，client端必须手动设置xhr.withCredentials=true，且server端也必须允许request能携带认证信息（即response header中包含Access-Control-Allow-Credentials:true），这样浏览器才会自动将cookie加在request header中。 另外，要特别注意一点，一旦跨域request能够携带认证信息，server端一定不能将Access-Control-Allow-Origin设置为*，否则就会面临攻击危险。 xhr相关事件事件分类xhr相关事件有很多，有时记起来还挺容易混乱。但当我了解了具体代码实现后，就容易理清楚了。下面是XMLHttpRequest的部分实现代码： 1234567891011121314151617181920interface XMLHttpRequestEventTarget : EventTarget &#123; // event handlers attribute EventHandler onloadstart; attribute EventHandler onprogress; attribute EventHandler onabort; attribute EventHandler onerror; attribute EventHandler onload; attribute EventHandler ontimeout; attribute EventHandler onloadend;&#125;;interface XMLHttpRequestUpload : XMLHttpRequestEventTarget &#123;&#125;;interface XMLHttpRequest : XMLHttpRequestEventTarget &#123; // event handler attribute EventHandler onreadystatechange; readonly attribute XMLHttpRequestUpload upload;&#125;; 从代码中我们可以看出： XMLHttpRequestEventTarget接口定义了7个事件： onloadstart onprogress onabort ontimeout onerror onload onloadend 每一个XMLHttpRequest里面都有一个upload属性，而upload是一个XMLHttpRequestUpload对象 XMLHttpRequest和XMLHttpRequestUpload都继承了同一个XMLHttpRequestEventTarget接口，所以xhr和xhr.upload都有第一条列举的7个事件 onreadystatechange是XMLHttpRequest独有的事件 所以这么一看就很清晰了：xhr一共有8个相关事件：7个XMLHttpRequestEventTarget事件+1个独有的onreadystatechange事件；而xhr.upload只有7个XMLHttpRequestEventTarget事件。 事件触发条件下面是我自己整理的一张xhr相关事件触发条件表，其中最需要注意的是 onerror 事件的触发条件。 事件 触发条件 onreadystatechange 每当xhr.readyState改变时触发；但xhr.readyState由非0值变为0时不触发。 onloadstart 调用xhr.send()方法后立即触发，若xhr.send()未被调用则不会触发此事件。 onprogress xhr.upload.onprogress在上传阶段(即xhr.send()之后，xhr.readystate=2之前)触发，每50ms触发一次；xhr.onprogress在下载阶段（即xhr.readystate=3时）触发，每50ms触发一次。 onload 当请求成功完成时触发，此时xhr.readystate=4 onloadend 当请求结束（包括请求成功和请求失败）时触发 onabort 当调用xhr.abort()后触发 ontimeout xhr.timeout不等于0，由请求开始即onloadstart开始算起，当到达xhr.timeout所设置时间请求还未结束即onloadend，则触发此事件。 onerror 在请求过程中，若发生Network error则会触发此事件（若发生Network error时，上传还没有结束，则会先触发xhr.upload.onerror，再触发xhr.onerror；若发生Network error时，上传已经结束，则只会触发xhr.onerror）。注意，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的xhr.statusCode是4xx时，并不属于Network error，所以不会触发onerror事件，而是会触发onload事件。 事件触发顺序当请求一切正常时，相关的事件触发顺序如下： 触发xhr.onreadystatechange(之后每次readyState变化时，都会触发一次) 触发xhr.onloadstart//上传阶段开始： 触发xhr.upload.onloadstart 触发xhr.upload.onprogress 触发xhr.upload.onload 触发xhr.upload.onloadend//上传结束，下载阶段开始： 触发xhr.onprogress 触发xhr.onload 触发xhr.onloadend 发生abort/timeout/error异常的处理在请求的过程中，有可能发生 abort/timeout/error这3种异常。那么一旦发生这些异常，xhr后续会进行哪些处理呢？后续处理如下： 一旦发生abort或timeout或error异常，先立即中止当前请求 将 readystate 置为4，并触发 xhr.onreadystatechange事件 如果上传阶段还没有结束，则依次触发以下事件： xhr.upload.onprogress xhr.upload.[onabort或ontimeout或onerror] xhr.upload.onloadend 触发 xhr.onprogress事件 触发 xhr.[onabort或ontimeout或onerror]事件 触发xhr.onloadend 事件 在哪个xhr事件中注册成功回调？从上面介绍的事件中，可以知道若xhr请求成功，就会触发xhr.onreadystatechange和xhr.onload两个事件。 那么我们到底要将成功回调注册在哪个事件中呢？我倾向于 xhr.onload事件，因为xhr.onreadystatechange是每次xhr.readyState变化时都会触发，而不是xhr.readyState=4时才触发。 123456xhr.onload = function () &#123; //如果请求成功 if(xhr.status == 200)&#123; //do successCallback &#125; &#125; 上面的示例代码是很常见的写法：先判断http状态码是否是200，如果是，则认为请求是成功的，接着执行成功回调。这样的判断是有坑儿的，比如当返回的http状态码不是200，而是201时，请求虽然也是成功的，但并没有执行成功回调逻辑。所以更靠谱的判断方法应该是：当http状态码为2xx或304时才认为成功。 123456xhr.onload = function () &#123; //如果请求成功 if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;= 200) || xhr.status == 304)&#123; //do successCallback &#125;&#125; 本文转自：segmentfault 结语最后给点扩展学习资料，如果你： 想真正搞懂XMLHttpRequest，最靠谱的方法还是看 W3C的xhr 标准; 想结合代码学习如何用XMLHttpRequest发各种类型的数据，可以参考html5rocks上的这篇文章 想粗略的了解XMLHttpRequest的基本使用，可以参考MDN的XMLHttpRequest介绍； 想了解XMLHttpRequest 的发展历程，可以参考阮老师的文章； 想了解Ajax的基本介绍，可以参考AJAX Tutorial; 想了解跨域请求，则可以参考W3C的 cors 标准; 想了解http协议，则可以参考HTTP Tutorial;","comments":true,"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://jiaosl.com/tags/JavaScript/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"http://jiaosl.com/tags/XMLHttpRequest/"},{"name":"http","slug":"http","permalink":"http://jiaosl.com/tags/http/"},{"name":"xhr","slug":"xhr","permalink":"http://jiaosl.com/tags/xhr/"}]},{"title":"javaScript中is-not-defined,undefined和null的区别","date":"2017-04-26T03:17:07.000Z","path":"2017/04/26/javaScript中is-not-defined、undefined和null的区别/","text":"is not defined与undefined之前没太注意is not defined和undefined有什么区别,每次都是简单的把两者理解为未定义,现在回过头来梳理js基础的时候才发现其中区别还是很鲜明的。先从单纯的字面意思来理解一下（有道词典）： is not defined: 未定义 not defined: 未定义,没有定义,无法定义 &amp;&amp; undefined: 不明确的单从字面意思大体也能看出两者的区别:前者是没有定义，也就是说没有;后者是不明确的,也就是说不知道有没有定义. not defined看demo1: 12console.log(a) // 报错:a is not defined 终止运行 一个未定义 的变量是没有声明的变量,这样的变量在使用时会直接报错误。 undefined一个定义了但未赋值的 变量demo2:123var aconsole.log(a) // 未报错,提示: undefined 一个定义了但把值赋为undefined的 变量demo3:1234var p = 1p = undefinedconsole.log(p) // 未报错,提示: undefined 一个对象没有赋值的属性demo4:12console.log(window.a)// 未报错,提示: undefined demo5:123var a = []console.log(a.b)// 未报错,提示: undefined demo6:123var a = &#123;&#125;console.log(a.b)// 未报错,提示: undefined 一个没有返回值的函数demo7:123function f() &#123;console.log(1)&#125;console.log(f())// 未报错,提示: undefined 有一点需要注意的是not defined 和 undefined 的typeof()的值都为”undefined”,所以无法用typeof()来判断这两者。 undefined 与 null两者相同–在if语句里都被解析为falsedemo8:12!undefined ? console.log(&apos;undefined is false&apos;) : console.log(&apos;undefined is not false&apos;)// undefined is false demo9:12!null? console.log(&apos;null is false&apos;) : console.log(&apos;null is not false&apos;)// null is false 用法的不同虽然null和undefined基本是同义的，但是在用法上还是有一些细微的差别的 nullnull表示“没有对象”,即此处不该有值 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。demo10:12Object.getPrototypeof(object.prototype)// null undefined如上文demo2-demo7 部分","comments":true,"categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://jiaosl.com/categories/javaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jiaosl.com/tags/javascript/"},{"name":"undefined","slug":"undefined","permalink":"http://jiaosl.com/tags/undefined/"}]},{"title":"转 javascript基础详解-执行环境与作用域链","date":"2017-04-25T10:30:59.000Z","path":"2017/04/25/javascript基础详解-执行环境与作用域链/","text":"函数调用都有与之相关的作用域和上下文。从根本上说，范围是基于函数(function-based)而上下文是基于对象(object-based)。换句话说，作用域是和每次函数调用时变量的访问有关，并且每次调用都是独立的。上下文总是关键字 this 的值，是调用当前可执行代码的对象的引用。 执行上下文栈(Execution Context Stack)在ECMASscript中的代码有三种类型：global, function和eval。 每一种代码的执行都需要依赖自身的上下文。当然global的上下文可能涵盖了很多的function和eval的实例。函数的每一次调用，都会进入函数执行中的上下文,并且来计算函数中变量等的值。eval函数的每一次执行，也会进入eval执行中的上下文，判断应该从何处获取变量的值。注意，一个function可能产生无限的上下文环境，因为一个函数的调用（甚至递归）都产生了一个新的上下文环境。 一系列活动的执行上下文从逻辑上形成一个栈。栈底总是全局上下文，栈顶是当前（活动的）执行上下文。当在不同的执行上下文间切换（退出的而进入新的执行上下文）的时候，栈会被修改（通过压栈或者退栈的形式）。 当javascript代码文件被浏览器载入后，默认最先进入的是一个全局的执行上下文。当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。浏览器总是执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出，然后，进入其下的上下文执行代码。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。 执行上下文(Execution Context)也称为执行环节，一个执行的上下文可以抽象的理解为object。每一个执行的上下文都有一系列的属性（我们称为上下文状态），他们用来追踪关联代码的执行进度。主要有三个属性：变量对象(variable object)，this指针(this value)，作用域链(scope chain)。 变量对象(Variable Object)变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。 它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。 它是一个抽象的概念，不同的上下文中，它表示使用不同的object。例如，在global全局上下文中，变量对象也是全局对象自身[global object]。（这就是我们可以通过全局对象的属性来指向全局变量）。 进入执行上下文时，VO的初始化过程具体如下： 函数的形参（当进入函数执行上下文时） 变量对象的一个属性，其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为undefined 函数声明（FunctionDeclaration, FD） 变量对象的一个属性，其属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则替换它的值 变量声明（var，VariableDeclaration） 变量对象的一个属性，其属性名即为变量名，其值为undefined;如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性。 执行代码的时候，VO的一些Undefined值会被确定。 活动对象(activation object)当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了。它包含普通参数(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。 即：函数的变量对象保持不变，但除去存储变量与函数声明之外，还包含以及特殊对象arguments 。 AO是在进入函数的执行上下文时创建的，并为该对象初始化一个arguments属性，该属性的值为Arguments对象。 作用域链(scope chain)作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。JS的语法风格和C/C++类似, 但作用域的实现却和C/C++不同，并非用“堆栈”方式，而是使用列表，具体过程如下(ECMA262中所述): 任何执行上下文时刻的作用域, 都是由作用域链(scope chain, 后面介绍)来实现. 在一个函数被定义的时候, 会将它定义时刻的scope chain链接到这个函数对象的[[scope]]属性. 在一个函数对象被调用的时候，会创建一个活动对象(也就是一个对象), 然后对于每一个函数的形参，都命名为该活动对象的命名属性, 然后将这个活动对象做为此时的作用域链(scope chain)最前端, 并将这个函数对象的[[scope]]加入到scope chain中. 在一般情况下，一个作用域链包括父级变量对象（variable object）（作用域链的顶部）、函数自身变量VO和活动对象（activation object）。不过，有些情况下也会包含其它的对象，例如在执行期间，动态加入作用域链中的—例如with或者catch语句。[译注：with-objects指的是with语句，产生的临时作用域对象；catch-clauses指的是catch从句，如catch(e)，这会产生异常对象，导致作用域变更]。 当查找标识符的时候，会从作用域链的活动对象部分开始查找，然后(如果标识符没有在活动对象中找到)查找作用域链的顶部，循环往复，就像作用域链那样。","comments":true,"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jiaosl.com/tags/javascript/"},{"name":"js基础","slug":"js基础","permalink":"http://jiaosl.com/tags/js基础/"},{"name":"执行上下文","slug":"执行上下文","permalink":"http://jiaosl.com/tags/执行上下文/"},{"name":"作用域链","slug":"作用域链","permalink":"http://jiaosl.com/tags/作用域链/"}]},{"title":"javascript基础详解-作用域","date":"2017-04-24T12:50:07.000Z","path":"2017/04/24/javascript基础详解-作用域/","text":"JavaScript语言的作用域仅存在于函数范围中。这是必须要牢记的一点，还有一点重要的就是作用域的提升规则。 作用域问题JS最容易出现混淆的就是作用域的情况。传统的类C语言,它们的作用域是block-level scope，块级作用域， 花括号就是一个作用域。但是对于JavaScript而言，它的作用域是function-level scope，比如if条件语句，就不算一个独立的作用域: 1234567var x = 1;console.log(x); // 1if (true) &#123; var x = 2; console.log(x); // 2&#125;console.log(x); // 2 JavaScript语言的作用域仅存在于函数范围中。这是必须要牢记的一点，还有一点重要的就是作用域的提升规则。 在JavaScript中，如果我们需要实现block-level scope，我们也有一种变通的方式，那就是通过自执行函数创建临时作用域: 12345678910function foo() &#123; var x = 1; if (x) &#123; (function () &#123; var x = 2; // some other code &#125;()); &#125; // x is still 1.&#125; 作用域提升变量被提升对JavaScript解释器而言，所有的函数和变量声明都会被提升到最前面, 并且变量声明永远在前面，赋值在声明过程之后。比如: 123var x = 10;function x()&#123;&#125;;console.log(x); // 10 实际上被解释为: 1234var x;function x()&#123;&#125;;x = 10;console.log(x); // 10 函数被提升函数的声明方式主要由两种：声明式和变量式。 声明式会自动将声明放在前面并且执行赋值过程。而变量式则是先将声明提升，然后到赋值处再执行赋值。比如: 1234567891011function test() &#123; foo(); // TypeError &quot;foo is not a function&quot; bar(); // &quot;this will run!&quot; var foo = function () &#123; // function expression assigned to local variable &apos;foo&apos; alert(&quot;this won&apos;t run!&quot;); &#125; function bar() &#123; // function declaration, given the name &apos;bar&apos; alert(&quot;this will run!&quot;); &#125;&#125;test(); 实际上等价于: 123456789101112131415function test() &#123; var foo; var bar; bar = function () &#123; // function declaration, given the name &apos;bar&apos; alert(&quot;this will run!&quot;); &#125; foo(); // TypeError &quot;foo is not a function&quot; bar(); // &quot;this will run!&quot; foo = function () &#123; // function expression assigned to local variable &apos;foo&apos; alert(&quot;this won&apos;t run!&quot;); &#125;&#125;test(); 主要注意的地方：带有命名的函数变量式声明，是不会提升到作用域范围内的，比如: 123var baz = function spam() &#123;&#125;;baz(); // vaildspam(); // ReferenceError &quot;spam is not defined&quot; 实战经验任何时候，请使用var声明变量, 并放置在作用域的顶端. 工具推荐JSLint之类，帮助你验证语法的规范。 JavaScript语言的作用域仅存在于函数范围中。这是必须要牢记的一点，还有一点重要的就是作用域的提升规则。 作用域问题JS最容易出现混淆的就是作用域的情况。传统的类C语言,它们的作用域是block-level scope，块级作用域， 花括号就是一个作用域。但是对于JavaScript而言，它的作用域是function-level scope，比如if条件语句，就不算一个独立的作用域: 1234567var x = 1;console.log(x); // 1if (true) &#123; var x = 2; console.log(x); // 2&#125;console.log(x); // 2 在JavaScript中，如果我们需要实现block-level scope，我们也有一种变通的方式，那就是通过自执行函数创建临时作用域: 12345678910function foo() &#123; var x = 1; if (x) &#123; (function () &#123; var x = 2; // some other code &#125;()); &#125; // x is still 1.&#125; 作用域提升变量被提升对JavaScript解释器而言，所有的函数和变量声明都会被提升到最前面, 并且变量声明永远在前面，赋值在声明过程之后。比如: 123var x = 10;function x()&#123;&#125;;console.log(x); // 10 实际上被解释为: 1234var x;function x()&#123;&#125;;x = 10;console.log(x); // 10 函数被提升函数的声明方式主要由两种：声明式和变量式。 声明式会自动将声明放在前面并且执行赋值过程。而变量式则是先将声明提升，然后到赋值处再执行赋值。比如: 1234567891011function test() &#123; foo(); // TypeError &quot;foo is not a function&quot; bar(); // &quot;this will run!&quot; var foo = function () &#123; // function expression assigned to local variable &apos;foo&apos; alert(&quot;this won&apos;t run!&quot;); &#125; function bar() &#123; // function declaration, given the name &apos;bar&apos; alert(&quot;this will run!&quot;); &#125;&#125;test(); 实际上等价于: 123456789101112131415function test() &#123; var foo; var bar; bar = function () &#123; // function declaration, given the name &apos;bar&apos; alert(&quot;this will run!&quot;); &#125; foo(); // TypeError &quot;foo is not a function&quot; bar(); // &quot;this will run!&quot; foo = function () &#123; // function expression assigned to local variable &apos;foo&apos; alert(&quot;this won&apos;t run!&quot;); &#125;&#125;test(); 主要注意的地方：带有命名的函数变量式声明，是不会提升到作用域范围内的，比如: 123var baz = function spam() &#123;&#125;;baz(); // vaildspam(); // ReferenceError &quot;spam is not defined&quot; 实战经验任何时候，请使用var声明变量, 并放置在作用域的顶端. 工具推荐JSLint之类，帮助你验证语法的规范。`","comments":true,"categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://jiaosl.com/tags/javaScript/"}]},{"title":"vim简单操作指南-cheat sheet","date":"2017-04-20T12:54:26.000Z","path":"2017/04/20/vim简单操作指南-cheat-sheet/","text":"在这里记录几个vim的常用命令和一张cheat sheet，方便查看 1. 选中。使用v进入可视模式，移动光标键选定内容。2. 复制的命令是y，即yank（提起） ，常用的命令如下：y 在使用v模式选定了某一块的时候，复制选定块到缓冲区用； yy 复制整行（yny ，复制n行，n为数字）； y^ 复制当前到行头的内容； y$ 复制当前到行尾的内容； yw 复制一个单词（ynw，复制n个单词，n为数字）； 3. 剪切的命令是d，即delete，d与y的用法基本相同.d 剪切选定块到缓冲区； dd 剪切整行 d^ 剪切至行首 d$ 剪切至行尾 dw 剪切一个word dG 剪切至档尾 4. 撤销u 撤销，可以无限撤销 U 撤销某一行最近所有修改 Ctrl+R 重做 ##注： 在正则表达式中，^表示匹配字符串的开始位置，$表示匹配字符串的结束位置。 命令前面加数字表示重复的次数， 加字母表示使用的缓冲区名称。 使用英文句号”.”可以重复上一个命令。 下面为一张vim cheat sheet 网上确实不好找 😂","comments":true,"categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"http://jiaosl.com/tags/vim/"}]},{"title":"hexo操作指南-常用命令","date":"2017-04-17T09:37:22.000Z","path":"2017/04/17/hexo操作指南-常用命令/","text":"hexo123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写12345hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 本地服务12345678hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动12hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 生成草稿1hexo publish [layout] &lt;title&gt; 模版123456789hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHubhexo new [layout] &lt;title&gt;hexo new photo &quot;My Gallery&quot;hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold）1hexo new photo &quot;My Gallery&quot; 设置文章摘要 ,以下是余下全文12### 写作 hexo new page hexo new post 12345678910111213| 变量 | 描述 || -------------|:-------------:|| :title | 标题 || :year | 建立的年份（4 位数） || :month | 建立的月份（2 位数） || :i_month | 建立的月份（去掉开头的零）|| :day | 建立的日期（2 位数） || :i_day| 建立的日期（去掉开头的零） |#### 推送到服务器上 hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g123#### 安装RSS插件 npm install hexo-generator-feed –save123开启RSS功能编辑hexo/_config.yml，添加如下代码： rss: /atom.xml #rss地址 默认即可`","comments":true,"categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jiaosl.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://jiaosl.com/tags/博客/"},{"name":"blog","slug":"blog","permalink":"http://jiaosl.com/tags/blog/"},{"name":"命令","slug":"命令","permalink":"http://jiaosl.com/tags/命令/"}]},{"title":"利用Hexo+coding搭建博客，优化github博客打开速度","date":"2017-04-17T08:32:25.000Z","path":"2017/04/17/利用Hexo-coding搭建博客，优化github博客打开速度/","text":"上次用hexo和github上搭建博客后，用了几天发现博客搭建在github上有一定的局限： 1. github服务器在国外，可能访问量太大，国内访问速度有些慢; 2. github屏蔽百度爬取，不利于seo; 所以，打算在coding上也搭建同样的hexo，然后通过解析让国内用户访问coding上的博客，国外用户访问github上的博客（貌似没什么国外的用户会看 ❥(^_-)）。上篇文章利用Hexo+github搭建博客，零成本、无需域名、服务器,对于整个流程讲的已经很详细，本文就简单介绍下流程。 什么是coding？简单的说coding就是类似于github的开源代码仓库，几乎是完全仿照github做的；虽然现在代码量并不多，但是部分地方还是比github方便一些的： 中文界面，对我们来用起来更加方便； 可以免费创建私有仓库； 虽然服务器也在国外，但访问速度比github要快不少注册coding并创建项目这一部分很简单，不多说。需要注意的是创建项目的时候项目名称跟我们在github上创建时候类似，项目名一定要是：用户名 + coding.me这样写的原因是此类pages服务中大都可以通过 {user_name}.域名 的项目名来访问此主页，(有兴趣请看coding的文档用户 Pages 与项目 Pages )开启pages服务进入刚创建好的项目，点pages服务，选择来源处选择master分支， 点击保存后，提示coding已运行在jiaosl.coding.me，说明开启成功，如下图: 配置SSH key此部分跟github上配置SSH Key完全相同，进入项目，设置，部署公钥，将你电脑上的公钥粘贴上就行。不懂的看上一篇文章。 hexo中添加coding仓库打开本地的hexo项目根目录下的_config.yml 配置文件，找到deploy，将coding中的项目地址填入进去。我们之前的repository是这样的 现在要同时发布到hithub和coding上，所以repository的值，就要改成键值对的形式列出来。如下图：要注意：.yml文件格式非常严格，冒号后面必须要有空格。 部署hexo到coding和github上在git bash中执行命令：1hexo d 现在我们每次执行部署命令，代码会同时提交到github和coding上。现在打开coding已经可以看到我们部署的hexo项目了,然后访问我们刚才开启的pages服务的域名jiaosl.coding.me,就可以看到我们的博客已经可以在coding上访问了。后面的内容依然是为需要使用自己的域名访问博客的用户写的，如果不需要自己的域名请略过。 解析域名到coding1. 将github的解析改成海外进入我的阿里云控制台，上次添加的解析是这样的 现在我们需要修改这个解析，点击 修改，然后将解析线路改成海外，然后保存，这样国外的用户访问你的博客的话会跳转到你的github的页面。 2. 添加CNAME解析到coding然后，点添加解析，我们再添加一条到coding的解析，记录类型选CNAME，记录值填你刚才pages服务给的地址，如：jiaosl.coding.me ，点击保存，如下图红色框框； 这样算是解析到了coding，接下来我们需要在coding的pages服务里，绑定我们的域名，解析才会有效果，进入项目的pages服务中，找到在绑定域名那里，填入你的域名，点击绑定，出现下图这样，就说明绑定成功。现在访问你的域名，就可以看到你的博客了。 最后我分别ping了两个网站的服务器，可以看出访问coding上的博客相对访问github还是要快一些的 到这里文章就结束了，如果文章对你有帮助，点个赞鼓励一下哦！ 个人独立博客：jiaosl.com","comments":true,"categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jiaosl.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://jiaosl.com/tags/博客/"},{"name":"blog","slug":"blog","permalink":"http://jiaosl.com/tags/blog/"},{"name":"github","slug":"github","permalink":"http://jiaosl.com/tags/github/"}]},{"title":"利用Hexo+github搭建博客，零成本、无需域名、服务器","date":"2017-04-14T02:16:04.000Z","path":"2017/04/14/利用Hexo-github搭建博客，零成本、无需域名、服务器/","text":"之前的博客是用wordpress搭建在阿里云的一台虚拟机上，由于出了个意外，造成我在上面写的文章全部丢失了，虽然不多，但是也都是心血。吸取教训我打算换种方式搭建博客，分析了目前比较流行的博客框架ghost、Jekyll、hexo，最终选择了hexo。hexo虽不如前两者那么火热，但还是很令我喜欢的： 依赖少(node),易安装 用markdown编写，生成纯静态文件，无需考虑库(前端最爱) 台湾人写的，中文文档友好 托管在github上，永不丢失 下面就开始文章的主要内容。 准备工作安装node很简单就跟平日装软件是一样的，如果不会看下面链接或者自行百度http://www.runoob.com/nodejs/nodejs-install-setup.html 安装Git同样不难，看下面链接或者自行百度https://jingyan.baidu.com/article/020278117cbe921bcc9ce51c.html注意：安装git第三步，要选择第二个（命令行模式），其他直接下一步。。。 注册github账号到github官网注册账号，有账号请略过 配置SSH Key注册完之后需要添加 SSH Key。SSH Key是一个认证，让github识别绑定这台机器，允许这台机器无需密码提交，修改项目。执行如下命令：1cd ~/. ssh ~这个符号，表示在用户目录下执行代码如果提示：No such file or directory 说明你是第一次使用git。下面就说下怎么配置SSH Key。 生产新的SSH Key配置在Git Bash(在任意文件夹中鼠标右击选择Git Bash Here打开)执行代码：1ssh-keygen -t rsa -C &quot;jsl1992@163.com&quot; 上面的邮箱记得修改成你自己的，成功后会生成两个文件id_rsa（私钥） 以及id_rsa.pub（公钥）。然后找到这两个文件，默认都在C盘 &gt; 用户 &gt; xxx &gt; .ssh 里面（xxx是计算机名字，我这里是jsl） 然后用文本编辑器把id_rsa_pub（公钥）这个文件打开，全选复制出来；然后打开在github上添加SSH Key，登录github账号，点击右上角用户头像，选择setting（设置）&gt; SSH and GPG keys &gt; NewSSH key然后把刚才复制的内容粘贴到key这里就可以了，title不用填，自己会识别 搭建博客安装Hexo在计算机上找个地方新建个blog文件夹，在Git Bash中。输入以下命令用于安装hexo(我用的是cnpm，跟npm是一样的，比npm速度快，感兴趣可以到这里安装 http://npm.taobao.org/)1npm i -g hexo 等安装完成后，输入hexo命令测试是否安装成功，成功的话会出现下图这样继续，我们初始化hexo，输入以下命令：1hexo init hexo 初始化成功会出现下图这样现在看你blog文件夹下就会出现一个hexo的文件夹，再次输入命令 ,进入hexo文目录：1cd hexo 进入hexo目录后，输入以下命令，安装hexo项目所依赖的文件：1npm i 然后输入以下命令，本地部署hexo1hexo generate 然后输入 以下命令就可以本地运行hexo了1hexo server 在浏览器中输入 http://localhost:4000 就能看到本地的默认博客页面了 现在hexo是基本搭建完成，接下来就是，将hexo和github连接起来。 配置github登录github，点击右上角加号，选择New repository(新建仓库) ####启用GitHub Page 点击github右上角头像，点Your profile，进入到你的github主页，那里能看到你刚创建的xxx.github.io项目,点进去，然后选择Settings，就进入到项目设置页面，往下拉找到GitHub Pages的框框处，点击“Launch automatic page generator”，如下图 进入后点击底部的”Continue to layouts“之后随意选择一个模板，点击“Publish page”，然后打开自己在github的静态网址，我的http://jiaosl.github.io 你会发现，打开是你自己刚才选择静态站点模版。 将本地hexo项目托管到Github进入hexo文件夹，找到_config.yml文件，用文本编辑器打开拉到底部，看到1deploy: 在deploy: 的下面加入以下代码：123type: gitrepository: git@github.com:jiaosl.github.io.gitbranch: master repository的值，对照着我的写，或者进入你刚才创建的git项目中，点击Clone or downloads，输入框里的内容就是repository的值。此文件里的其他信息，都是网站的配置信息，以后可以自己修改， 安装hexo-deployer-git插件1npm i hexo-deployer-git --save 部署你本地的主题到github上依次运行以下命令123hexo cleanhexo generate # or hexo ghexo deploy #or hexo d 最后打开github项目的网站 jiaosl.github.io,就可以看到你的博客页面了. 域名绑定github如果看到这里说明你已经搭建成功了，接下来如果想要把自己的域名绑定到刚搭建的博客里，请继续看。 域名解析将自己的域名添加一条CNAME记录， 我用的是阿里云的域名，点击解析按钮，记录类型选择CNAME，主机记录可以不用填，记录值写你的github的二级域名，我的是jiaosl.github.io 然后保存就可以了，大约一两分钟会生效 光是解析到github是不行的，还需要我们在github中配置，允许我们的域名解析到这里，我们在本地hexo目录下的source中新建一个文件： CNAME 注意这个文件没有后缀名 打开CNAME文件，将我们的域名填入，然后保存，例如我的是 jiaosl.com 然后发布我们的代码到github，等几分钟就可以可以访问了（上传文章有延迟），发布也就是我们前面的两步12hexo ghexo d 到这里搭建基本结束，后续还会有hexo详细操作和，换主题的文章。","comments":true,"categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jiaosl.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://jiaosl.com/tags/博客/"},{"name":"blog","slug":"blog","permalink":"http://jiaosl.com/tags/blog/"},{"name":"node","slug":"node","permalink":"http://jiaosl.com/tags/node/"}]}]